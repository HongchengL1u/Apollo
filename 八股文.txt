1. 封装，继承，多态
	封装： class 和 struct 数据结构进行封装，有public和private两种访问权限
	继承： 子类继承父类，分为三种继承（构造函数、析构函数、友元函数、静态数据成员、静态成员函数都不能被继承）
	多态： 
		动态多态(重写)：
			1. override的实现是通过虚函数表，子类定义父类声明的虚函数，不同类型的指针可以通过虚函数表对应不同类型的函数
			2. 重写函数的访问修饰符可以不同，尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的
		静态多态（重载）： 覆盖，这些在编译时，就决定了使用哪个函数

2. final（标识符类似于override）: 禁止继承！
	
3. 虚函数通过虚函数表实现
	在构造函数时，会根据类内虚函数声明（继承类隐式声明），生成虚函数表存储该类命名空间定义函数，类内创造一个虚函数表指针
	在调用时，会根据指针的指向的类型，找到对应类型的虚函数指针，执行对应类型的函数
4. 智能指针的本质是什么，它们的实现原理是什么？
	智能指针是一个RAII思想的模板类
	有私有指针？
	公共指针是一个原指针的wrapper，重写了括号的操作符，包含一个num,用于记录该类的指针次数

5. 匿名函数的本质是什么？他的优点是什么？
	匿名函数，就是一个函数，优点？

6. 右值引用是什么，为什么要引入右值引用？
	std::move &&
	避免深拷贝

7. 左值引用和指针的区别？
	左值引用和指针本质一样，都是通过地址，改变对应变量
	引用类似于一种别名，一旦初始化，就不能更改为其他变量的引用，别名和原来变量的地址相同

8. 指针是什么？
	指针是一个8字节的变量，存储变量在内存空间的地址
	能够通过指针改变可写空间的内容

9. weak_ptr真的不计数？是否有计数方式，在哪分配的空间。
	不知道

10. malloc的内存分配的方式，有什么缺点？
	malloc 内存申请是在堆上，有啥缺点？
	
11.1 为什么不全部使用mmap来分配内存？

11.2 为什么不全部都用brk

12 传入一个指针，它如何确定具体要清理多少空间呢？
	啥意思？
	
13. define和const的区别是什么？
	define是预编译时，单纯的内容替换
	const是常量声明

14. 程序运行的步骤是什么
	在Linux上，首先是执行加载器，将libc.so 或者stdc++.so 加载到内存中
	再执行源代码
	最后syscall
	最后执行exit_group

15. 互斥锁的底层原理是
		获取锁（原子锁），执行CAS，若成功则进入临界区，若不成功则通过syscall进入睡眠

16. 原子操作是什么？
	CPU一个核，原子操作执行时，该线程独占这一个核，

17. class与struct的区别
	class 默认为private
	struct 默认为public
	class 在面向对象变成语言中，除了抽象之外，还有多态和继承
	
18. 内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？
	内存对齐是，对于struct和class这些
	变量内存空间分配时，
	1. 分配地址为该变量大小的整数倍
	2. 大小最终也时最大的那个变量的大小的整数倍
	
	为了CPU读取变量的高效，因为CPU读取是64位读的
	
19. 进程之间的通信方式有哪些？
	socket
	管道

20. 线程之间的通信方式有哪些？

21. 介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式

22. 类的生命周期
	分为局部变量和全局变量
	分为静态变量等
	还有就是heap和stack

23. 父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？
	父类构造函数不能，因为虚函数表本身就是在类的构造函数中创建的
	析构函数，如果需要使用类的多态特性的话，就需要将析构函数声明为虚函数
	
24. 多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？
	因为会陷入没人释放锁
	解决死锁，可以通过信号量和条件变量这些

25. 描述一下面向过程和面向对象
	

26. C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？

27. 介绍一下vector、list的底层实现原理和优缺点
	vector主要是多分配一点空间，占用空间，增添删除元素很方便
	list与C的数组类似

28. 静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）
	在data段
	静态变量在编译之后，就初始化了，在可执行文件内部占据空间

29. 如何实现多进程？
	fork
	exe？

30. 空对象指针为什么能调用函数？

31. shared_ptr线程安全吗？
	不安全，因为shared_ptr本身就是一个共享空间

32. push_back()左值和右值的区别是什么？
	都是深拷贝
	
33. move底层是怎么实现的？

34. 完美转发的原理是什么？

35. 空类中有什么函数？
	构造函数和析构函数

36. explicit用在哪里？有什么作用？
	防止隐式的类型转换

37. 成员变量初始化的顺序是什么？
	根据声明顺序

38. 指针占用的大小是多少？
	64位 8字节
	32位 4字节

39. 野指针和内存泄漏是什么？如何避免？
	采用智能指针

40. malloc和new的区别是什么？
	malloc是C，new是C++
	malloc需要指定大小
	new需要指定类型
	malloc返回值位void* 需要隐式或者显式的类型转换
	new返回值就是对应类型的指针

41. 多线程会发生什么问题？线程同步有哪些手段？
	访问共享内存时，会出现问题
	信号量和条件变量

42. 什么是STL？
	C++ 标准库

43. 对比迭代器和指针的区别

44. 线程有哪些状态，线程锁有哪些？
	运行
	挂起
	终止

45. 解释说明一下map和unordered_map
	map是一个dict，根据key的大小顺序进行排列
	unordered_map是一个无序的dict

46. vector中的push_back()和emplace_back()的区别、以及使用场景

47. 如何实现线程安全，除了加锁还有没有其他的方式？

48. vector扩容，resize和reserve的区别

49. vector扩容为了避免重复扩容做了哪些机制？
	每次扩容都会比之前扩容多一倍

50. C++中空类的大小是多少？
	一个字节

51. weak_ptr是怎么实现的？

52. 虚函数的底层原理是什么？
	虚函数对应虚函数表
	当类定义虚函数，虚函数表会存储函数入口地址
	类中仅仅存储虚函数表的指针

53. 一个函数f(int a,int b)，其中a和b的地址关系是什么？
	先右后左
	局部变量，存储在栈，栈是向上的，堆是向下的

54. 移动构造和拷贝构造的区别是什么？
	移动构造 浅拷贝
	拷贝构造 深拷贝

55. lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？

56. 哈希碰撞的处理方法
	hash冲突，出现hash冲突，如果说是链式结构的hash，会放在hash计算的index对应链表的最后一个
	如果是线性的，会放在index的后面一个

57. unordered_map的扩容过程

58. vector如何判断应该扩容？（size和capacity）

59. 构造函数是否能声明为虚函数？为什么？什么情况下为错误？
	不能
	
60. 类中static函数是否能声明为虚函数？
	不能，因为static是静态的，在编译的时候，就创建了
	而虚函数表则是要等到运行时，才会创建

61. 哪些函数不能被声明为虚函数？

62. 如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）
	new

63. 讲讲你理解的虚基类

64. C++哪些运算符不能被重载？
	++ --

65. 动态链接和静态链接的区别，动态链接的原理是什么？
	动态链接运行时加载
	静态链接编译之后就已经加载到可执行文件中了
	动态链接的原理？

66. C++中怎么编译C语言代码？
	extern C

67. 未初始化的全局变量和初始化的全局变量放在哪里？
	.bss
	data

68. 说一下内联函数及其优缺点
	
	
69. C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

70. map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)

71. 详细说一说fcntl的作用

72. C++的面向对象主要体现在那些方面？

73. 介绍一下extern C关键字，为什么会有这个关键字？
	extern C是将{}内代码以C语言的形式进行编译，因为C++和C的区别
	
74. 讲一讲迭代器失效及其解决方法
	迭代器的容器变化了，长度变化


75. 编译器是如何实现重载的？
	会扫描头文件内的函数声明
	重载的函数，应该有同样的函数名，和返回类型
	会优先匹配变量类型相近的

76. 什么是函数调用约定？

77. 使用条件变量的时候需要注意什么？
	需要避免死锁

78. 类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？
	可以，不可以
	普通成员会隐式传入this指针
	但是静态函数则没有
	
79. 强制类型转换有哪几种类型，分别有什么特点？原理是什么？
	static_cast<>


80. 回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

81. Linux中的信号有哪些？

82. 什么是尾递归？

83. 为什么会有栈溢出，为什么栈会设置容量？

84. 二叉树和平衡二叉树的区别

85. 平衡二叉树的优缺点

86. 什么是this指针，为什么存在this指针？
	为了函数能够访问类内变量
	
87. 什么是重载、重写、隐藏？
	重载
	重写override
	隐藏声明了一个新的，只有函数名一样
	
88. 静态成员函数可以是虚函数吗？为什么？
	不可以

89. 构造函数可以为虚函数吗？为什么？
	不可以

90. make_shared函数的优点，缺点？
	可以浅拷贝，减少深拷贝带来的时间浪费
	缺点就是被make_shared的变量地址会变为null
	
91. 函数调用进行的操作：
